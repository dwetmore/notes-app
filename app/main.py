import os
import sqlite3
from datetime import datetime
from typing import List, Optional

from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

# Path to the SQLite database. If not provided via the environment this
# defaults to a file inside the container's persistent volume. Keeping
# the database on disk means notes persist across container restarts.
DB_PATH = os.environ.get("DB_PATH", "/data/notes.db")
STATIC_DIR = os.path.join(os.path.dirname(__file__), "static")

app = FastAPI(title="Notes App")

# Serve the static front‑end from `/static` so that the index.html and
# associated assets can be retrieved by browsers.
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")


class NoteIn(BaseModel):
    """Incoming payload for creating or updating a note."""
    title: str
    body: str


class NoteOut(NoteIn):
    """Representation of a note returned to clients.

    Includes an ID generated by the database and an optional creation
    timestamp.  Existing records without a timestamp will return
    ``None`` for ``created_at``.
    """
    id: int
    created_at: Optional[str] | None = None


def db() -> sqlite3.Connection:
    """Return a connection to the SQLite database and ensure the schema.

    If the underlying database file does not exist, it will be created.
    The schema is automatically migrated to include a ``created_at``
    column if it doesn't already exist.  Additional migrations can be
    added here following a similar pattern.
    """
    # Ensure the directory for the database exists
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    # Create the notes table with a created_at column if it does not exist
    conn.execute(
        "CREATE TABLE IF NOT EXISTS notes (\n"
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,\n"
        "  title TEXT NOT NULL,\n"
        "  body TEXT NOT NULL,\n"
        "  created_at TEXT\n"
        ")"
    )
    # Attempt to add the created_at column in case an older schema is present.
    try:
        conn.execute("ALTER TABLE notes ADD COLUMN created_at TEXT")
    except sqlite3.OperationalError:
        # The column already exists or cannot be added; ignore the error.
        pass
    return conn


@app.get("/")
def root():
    """Serve the single page application front‑end."""
    return FileResponse(os.path.join(STATIC_DIR, "index.html"))


@app.get("/healthz")
def healthz():
    """Simple liveness probe used by Kubernetes."""
    return {"status": "ok"}


@app.get("/readyz")
def readyz():
    """Readiness probe that checks DB connectivity."""
    try:
        conn = db()
        conn.execute("SELECT 1")
        conn.close()
        return {"ready": True}
    except Exception as e:  # pylint: disable=broad-except
        raise HTTPException(status_code=503, detail=str(e))


@app.get("/api/notes", response_model=List[NoteOut])
def list_notes(q: Optional[str] = Query(default=None, description="Optional search term")):
    """Return all notes ordered by newest first.

    If a query string ``q`` is provided, only notes with a title or body
    containing the query term (case insensitive) will be returned.
    """
    conn = db()
    if q:
        # Surround the search term with wildcards for LIKE.  SQLite's
        # default collation is case sensitive, so lower both sides to
        # perform a case‑insensitive search.
        like = f"%{q}%"
        rows = conn.execute(
            "SELECT id, title, body, created_at FROM notes "
            "WHERE lower(title) LIKE lower(?) OR lower(body) LIKE lower(?) "
            "ORDER BY id DESC",
            (like, like),
        ).fetchall()
    else:
        rows = conn.execute(
            "SELECT id, title, body, created_at FROM notes ORDER BY id DESC"
        ).fetchall()
    conn.close()
    # Convert sqlite3.Row objects into plain dicts so that pydantic can
    # serialize them correctly.
    return [dict(r) for r in rows]


@app.post("/api/notes", response_model=NoteOut)
def create_note(note: NoteIn):
    """Insert a new note into the database and return it."""
    conn = db()
    created_at = datetime.utcnow().isoformat()
    cur = conn.execute(
        "INSERT INTO notes (title, body, created_at) VALUES (?, ?, ?)",
        (note.title, note.body, created_at),
    )
    conn.commit()
    new_id = cur.lastrowid
    conn.close()
    return {"id": new_id, **note.model_dump(), "created_at": created_at}


@app.put("/api/notes/{note_id}", response_model=NoteOut)
def update_note(note_id: int, note: NoteIn):
    """Update an existing note's title and body.

    Returns the updated note, or a 404 if the note does not exist.
    """
    conn = db()
    cur = conn.execute(
        "UPDATE notes SET title = ?, body = ? WHERE id = ?",
        (note.title, note.body, note_id),
    )
    conn.commit()
    if cur.rowcount == 0:
        conn.close()
        raise HTTPException(status_code=404, detail="not found")
    # Fetch the updated record so we can return the created_at value
    row = conn.execute(
        "SELECT id, title, body, created_at FROM notes WHERE id = ?",
        (note_id,),
    ).fetchone()
    conn.close()
    return dict(row)


@app.delete("/api/notes/{note_id}")
def delete_note(note_id: int):
    """Delete a note by ID.

    Returns the ID of the deleted note or a 404 if it does not exist.
    """
    conn = db()
    cur = conn.execute("DELETE FROM notes WHERE id = ?", (note_id,))
    conn.commit()
    conn.close()
    if cur.rowcount == 0:
        raise HTTPException(status_code=404, detail="not found")
    return {"deleted": note_id}